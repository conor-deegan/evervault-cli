use nom::{
    branch::alt,
    bytes::streaming::{tag, take_until, take_while, take_while_m_n},
    combinator::{map_res, opt},
    sequence::tuple,
    IResult,
};
use std::fmt::Formatter;

// Type is generated by parse_ciphertexts, which is currently unused
#[allow(dead_code)]
type ParsedCiphertext<'a> = (
    &'a [u8], // prefix bytes
    &'a [u8], // delimiter
    Option<CiphertextVersion>,
    Option<&'a [u8]>, // optional delimiter
    Option<Datatype>,
    Option<&'a [u8]>, // optional delimiter
    &'a [u8],         // iv
    &'a [u8],         // delimiter
    &'a [u8],         // public key
    &'a [u8],         // delimiter
    &'a [u8],         // encrypted value
    &'a [u8],         // delimiter
    &'a [u8],         // suffix
);

pub fn find_ciphertext_prefix(input: &[u8]) -> IResult<&[u8], &[u8]> {
    take_until("ev:")(input)
}

// This function will be used, temporarily disabling linter
#[allow(dead_code)]
pub fn parse_ciphertexts(input: &[u8]) -> IResult<&[u8], Option<Ciphertext>> {
    let (input, parsed_ct) = opt(ciphertext)(input)?;
    Ok((input, parsed_ct.map(Ciphertext::new)))
}

fn ciphertext(input: &[u8]) -> IResult<&[u8], ParsedCiphertext> {
    tuple((
        ciphertext_prefix,
        ciphertext_delimiter,
        opt_version,
        opt(ciphertext_delimiter),
        opt_datatype,
        opt(ciphertext_delimiter),
        ciphertext_iv,
        ciphertext_delimiter,
        ciphertext_public_key,
        ciphertext_delimiter,
        ciphertext_encrypted_value,
        ciphertext_delimiter,
        ciphertext_suffix,
    ))(input)
}

// Type is generated by parse_ciphertexts, which is currently unused
#[allow(dead_code)]
pub struct Ciphertext {
    version: Option<CiphertextVersion>,
    datatype: Option<Datatype>,
    iv: Vec<u8>,
    public_key: Vec<u8>,
    encrypted_value: Vec<u8>,
}

impl Ciphertext {
    fn new(parsed: ParsedCiphertext) -> Self {
        let (_prefix, _, version, _, datatype, _, iv, _, pub_key, _, encrypted_val, _, _) = parsed;
        Self {
            version,
            datatype,
            iv: iv.to_vec(),
            public_key: pub_key.to_vec(),
            encrypted_value: encrypted_val.to_vec(),
        }
    }

    // Ciphertext cannot be empty but len is dependent on the encrypted value and needs to be computed
    #[allow(clippy::len_without_is_empty)]
    pub fn len(&self) -> usize {
        // prefix len
        3 + self.version.as_ref().map(|_| 5).unwrap_or(0) // version + delimiter
            + self.datatype.as_ref().map(|dt| dt.len() + 1).unwrap_or(0) // type + delimiter
            + self.iv.len()
            + 1 // delimiter
            + self.public_key.len()
            + 1 // delimiter
            + self.encrypted_value.len()
            + 2 // delimiter + suffic
    }
}

fn ciphertext_prefix(input: &[u8]) -> IResult<&[u8], &[u8]> {
    tag(b"ev")(input)
}

fn ciphertext_delimiter(input: &[u8]) -> IResult<&[u8], &[u8]> {
    tag(b":")(input)
}

fn ciphertext_iv(input: &[u8]) -> IResult<&[u8], &[u8]> {
    take_while_m_n(16, 16, is_base64)(input)
}

fn ciphertext_public_key(input: &[u8]) -> IResult<&[u8], &[u8]> {
    take_while_m_n(44, 44, is_base64)(input)
}

fn ciphertext_encrypted_value(input: &[u8]) -> IResult<&[u8], &[u8]> {
    take_while(is_base64)(input)
}

fn ciphertext_suffix(input: &[u8]) -> IResult<&[u8], &[u8]> {
    tag(b"$")(input)
}

fn is_base64(input: u8) -> bool {
    input.is_ascii_alphanumeric() || input == b'=' || input == b'/'
}

fn opt_version(input: &[u8]) -> IResult<&[u8], Option<CiphertextVersion>> {
    // match against any of the valid version tags
    map_res(
        opt(alt((tag(b"RFVC"), tag(b"T1JL"), tag(b"Tk9D")))),
        CiphertextVersion::from_bytes,
    )(input)
}

fn opt_datatype(input: &[u8]) -> IResult<&[u8], Option<Datatype>> {
    // match against any of the valid version tags
    map_res(
        opt(alt((tag(b"string"), tag(b"boolean"), tag(b"number")))),
        Datatype::from_bytes,
    )(input)
}

#[derive(Clone, Debug, PartialEq)]
enum CiphertextVersion {
    Rfvc,
    T1jl,
    Tk9d,
}

impl CiphertextVersion {
    fn from_bytes(bytes: Option<&[u8]>) -> Result<Option<Self>, ()> {
        bytes.map(Self::try_from).transpose()
    }
}

impl std::convert::TryFrom<&[u8]> for CiphertextVersion {
    type Error = ();

    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        let version = match value {
            b"RFVC" => CiphertextVersion::Rfvc,
            b"T1JL" => CiphertextVersion::T1jl,
            b"Tk9D" => CiphertextVersion::Tk9d,
            _ => return Err(()),
        };
        Ok(version)
    }
}

impl std::fmt::Display for CiphertextVersion {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Self::Rfvc => "RFVC",
                Self::T1jl => "T1JL",
                Self::Tk9d => "Tk9D",
            }
        )
    }
}

#[derive(Clone, Debug, PartialEq)]
enum Datatype {
    Boolean,
    Number,
    String,
}

impl Datatype {
    fn from_bytes(bytes: Option<&[u8]>) -> Result<Option<Self>, ()> {
        bytes.map(Self::try_from).transpose()
    }

    fn len(&self) -> usize {
        match self {
            Self::Boolean => 7,
            Self::Number => 6,
            Self::String => 6,
        }
    }
}

impl std::convert::TryFrom<&[u8]> for Datatype {
    type Error = ();

    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        let datatype = match value {
            b"boolean" => Datatype::Boolean,
            b"string" => Datatype::String,
            b"number" => Datatype::Number,
            _ => return Err(()),
        };
        Ok(datatype)
    }
}

impl std::fmt::Display for Datatype {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Self::Boolean => "boolean",
                Self::Number => "number",
                Self::String => "",
            }
        )
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use std::io::Write;

    fn build_ciphertext(
        version: Option<&CiphertextVersion>,
        datatype: Option<&Datatype>,
    ) -> Vec<u8> {
        let mut ciphertext = Vec::new();
        ciphertext.write(b"ev:").unwrap();
        if let Some(version) = version.map(|v| v.to_string()) {
            ciphertext.write(version.as_bytes()).unwrap();
            ciphertext.write(b":").unwrap();
        }
        if let Some(dt) = datatype.map(|dt| dt.to_string()) {
            ciphertext.write(dt.as_bytes()).unwrap();
            ciphertext.write(b":").unwrap();
        }
        ciphertext.write(b"YGJVktHhdj3ds3wC:A6rkaTU8lez7NSBT8nTqbhBIu3tX4/lyH3aJVBUcGmLh:8hI5qEp32kWcVK367yaC09bDRbk:$").unwrap();
        ciphertext
    }

    macro_rules! build_ciphertext_test {
        ($ver:ident) => {
            let ciphertext_vec = build_ciphertext($ver.as_ref(), None);
            let (input, ciphertext) =
                parse_ciphertexts(ciphertext_vec.as_slice()).expect("No parse error");
            assert_eq!(input.len(), 0);
            assert_eq!(ciphertext.as_ref().unwrap().datatype, None);
            assert_eq!(ciphertext.as_ref().unwrap().version, $ver);
        };
        ($ver:ident,$dt:path) => {
            let ciphertext_vec = build_ciphertext($ver.as_ref(), Some(&$dt));
            let (input, ciphertext) =
                parse_ciphertexts(ciphertext_vec.as_slice()).expect("No parse error");
            assert_eq!(input.len(), 0);
            assert_eq!(ciphertext.as_ref().unwrap().datatype, Some($dt));
            assert_eq!(ciphertext.as_ref().unwrap().version, $ver);
        };
    }

    #[test]
    fn test_ciphertext_parse_with_no_version() {
        build_ciphertext_test!(None);
        build_ciphertext_test!(None, Datatype::Boolean);
        build_ciphertext_test!(None, Datatype::Number);
    }

    #[test]
    fn test_ciphertext_parse_with_versions() {
        let tk9d = Some(CiphertextVersion::Tk9d);
        build_ciphertext_test!(tk9d);
        build_ciphertext_test!(tk9d, Datatype::Boolean);
        build_ciphertext_test!(tk9d, Datatype::Number);
        let t1jl = Some(CiphertextVersion::T1jl);
        build_ciphertext_test!(t1jl);
        build_ciphertext_test!(t1jl, Datatype::Boolean);
        build_ciphertext_test!(t1jl, Datatype::Number);
        let rfvc = Some(CiphertextVersion::Rfvc);
        build_ciphertext_test!(rfvc);
        build_ciphertext_test!(rfvc, Datatype::Boolean);
        build_ciphertext_test!(rfvc, Datatype::Number);
    }
}
